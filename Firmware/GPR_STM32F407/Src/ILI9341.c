// ILI9341
#include "stm32f4xx.h"                  // Device header
#include "ILI9341.h"
#include "functions.h"

// Command and data for FSMC bank1
#define ADDR_CMD         *(volatile uint16_t*)0x60000000		// Bank 1
#define ADDR_DATA        *(volatile uint16_t*)0x60080000	// A18 -> 18+1 bit

unsigned short X_SIZE=240;
unsigned short Y_SIZE=320;
int temp;	// For swap

const tGPIO_Line displayIO[] = {
	{GPIOD, 0, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOD, 1, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOD, 4, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOD, 5, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOD, 7, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOD, 8, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOD, 9, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOD, 10, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOD, 13, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOD, 14, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOD, 15, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOE, 7, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOE, 8, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOE, 9, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOE, 10, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOE, 11, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOE, 12, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOE, 13, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOE, 14, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
	{GPIOE, 15, GPIO_MODE_AF_PP, GPIO_SPEED_FREQ_VERY_HIGH, GPIO_NOPULL, GPIO_AF12_FSMC, 0},
};

void ili9341_init_mcu(){
	// FSMC - display
	SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIODEN);
	SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIOEEN);
	configureIO(displayIO,sizeof(displayIO)/sizeof(tGPIO_Line));
	// FSMC
	SET_BIT(RCC->AHB3ENR,RCC_AHB3ENR_FSMCEN);
	WRITE_REG(FSMC_Bank1E->BWTR[0],0x0FFFFFFF);
	WRITE_REG(FSMC_Bank1->BTCR[0+0],	// BCR1
		0U<<FSMC_BCR1_CBURSTRW_Pos|	// write 0 - async 1 - sycnc
		0U<<FSMC_BCR1_ASYNCWAIT_Pos|	// Wait signal during asynchronous transfers
		0U<<FSMC_BCR1_EXTMOD_Pos|		// Extended mode enable. Use BWTR register or no
		0U<<FSMC_BCR1_WAITEN_Pos|		// Wait enable bit.
		1U<<FSMC_BCR1_WREN_Pos|			// Write enable bit
		0U<<FSMC_BCR1_WAITCFG_Pos|		// Wait timing configuration. 0: NWAIT signal is active one data cycle before wait state 1: NWAIT signal is active during wait state
		0U<<FSMC_BCR1_WRAPMOD_Pos|		// Wrapped burst mode support
		0U<<FSMC_BCR1_WAITPOL_Pos|		// Wait signal polarity bit. 0: NWAIT active low. 1: NWAIT active high
		0U<<FSMC_BCR1_BURSTEN_Pos|		// Burst enable bit
		1U<<FSMC_BCR1_FACCEN_Pos|		// Flash access enable
		1U<<FSMC_BCR1_MWID_Pos|			// 0 = 8b 1 = 16b
		2U<<FSMC_BCR1_MTYP_Pos|			// 0 = SRAM 1 = CRAM 2 = NOR
		0U<<FSMC_BCR1_MUXEN_Pos|			// Multiplexing Address/Data
		1U<<FSMC_BCR1_MBKEN_Pos			// Memory bank enable bit
		);
	WRITE_REG(FSMC_Bank1->BTCR[0+1],	// BTR1
		0U<<FSMC_BTR1_ADDSET_Pos|		// Address setup phase duration 0..F * HCLK
		0U<<FSMC_BTR1_ADDHLD_Pos|		// Address-hold phase duration 1..F * 2 * HCLK
		15U<<FSMC_BTR1_DATAST_Pos|		// Data-phase duration 1..FF * 2 * HCLK
		0U<<FSMC_BTR1_BUSTURN_Pos|		// Bus turnaround phase duration 0...F
		1U<<FSMC_BTR1_CLKDIV_Pos|		// for FSMC_CLK signal 1 = HCLK/2, 2 = HCLK/3 ...  F= HCLK/16
		0U<<FSMC_BTR1_DATLAT_Pos|		// Data latency for synchronous NOR Flash memory 0(2CK)...F(17CK)
		0U<<FSMC_BTR1_ACCMOD_Pos			// Access mode 0 = A, 1 = B, 2 = C, 3 = D Use w/EXTMOD bit
	);
	// Backlight
	SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIODEN);
	WRITE_REG(GPIOB->BSRR,(1U<<LCD_BL)<<16);
	MODIFY_REG(GPIOB->MODER,3U<<LCD_BL*2,
		GPIO_MODE_OUTPUT_PP<<LCD_BL*2);
	MODIFY_REG(GPIOB->OTYPER,1U<<LCD_BL,
		(GPIO_MODE_OUTPUT_PP>>1)<<LCD_BL);
	MODIFY_REG(GPIOB->OSPEEDR,3U<<LCD_BL*2,
		GPIO_SPEED_FREQ_VERY_HIGH<<LCD_BL*2);
	MODIFY_REG(GPIOB->PUPDR,3U<<LCD_BL*2,
		GPIO_PULLUP<<LCD_BL*2);
		
	// DMA2, stream 0, channel 0
	SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_DMA2EN);
	DMA2_Stream0->CR = 0<<DMA_SxCR_CHSEL_Pos
		|3<<DMA_SxCR_PL_Pos
		|1<<DMA_SxCR_MSIZE_Pos
		|1<<DMA_SxCR_PSIZE_Pos
		|0<<DMA_SxCR_CT_Pos
		|1*DMA_SxCR_MINC
		|2<<DMA_SxCR_DIR_Pos
		|0*DMA_SxCR_TCIE;
	uint32_t COLOR_DST = 0xAAAAAAAA;
	DMA2_Stream0->M0AR = (uint32_t)&ADDR_DATA;
//	DMA2_Stream0->M0AR = (uint32_t)&COLOR_DST;
//	uint32_t COLOR = 0xFFFFFFFF;
//	DMA2_Stream0->M1AR = (uint32_t) &COLOR;
//	DMA2_Stream0->NDTR = 3;
//	DMA2_Stream0->CR |= DMA_SxCR_EN;
//	while((DMA2->LISR & DMA_LIFCR_CTCIF0) == 0){};
//	DMA2->LIFCR = DMA_LIFCR_CTCIF0;
}

void ili9341_dma_wait(){
	while((DMA2->LISR&DMA_LISR_TCIF0)==0);
	DMA2->LIFCR = DMA_LIFCR_CTCIF0;
//	CLEAR_BIT(DMA2_Stream0->CR,DMA_SxCR_EN);
}

void ili9341_dma_send(short *data, int len){
	CLEAR_BIT(DMA2_Stream0->CR,DMA_SxCR_EN);
	DMA2_Stream0->M1AR = (uint32_t)data;
	DMA2_Stream0->NDTR = len;
	SET_BIT(DMA2_Stream0->CR,DMA_SxCR_EN);
}

void ili9341_init(int hor, int ver){
	X_SIZE = hor;
	Y_SIZE = ver;
	
	GPIOB->BSRR = 1<<LCD_BL;
	
	char x; int id;
	ADDR_CMD = ILI9341_READ_ID4;
	x = ADDR_DATA;
	id = x; id <<= 8;
	x = ADDR_DATA;
	id |= x; id <<= 8;
	x = ADDR_DATA;
	id |= x; id <<= 8;
	x = ADDR_DATA;
	id |= x;
	
	// Init display
	ADDR_CMD=ILI9341_RST;
	delay_us(100*1e3);
	ADDR_CMD=ILI9341_DISPLAY_OFF;
	ADDR_CMD=ILI9341_POWER_CONTROLA;
	ADDR_DATA=0x39;
	ADDR_DATA=0x2C;
	ADDR_DATA=0x00;
	ADDR_DATA=0x34;
	ADDR_DATA=0x02;
	ADDR_CMD=ILI9341_POWER_CONTROLB;
	ADDR_DATA=0x00;
	ADDR_DATA=0x83;
	ADDR_DATA=0x30;
	ADDR_CMD=ILI9341_DRIVER_TIMING_CONTROLA;
	ADDR_DATA=0x85;
	ADDR_DATA=0x01;
	ADDR_DATA=0x79;
	ADDR_CMD=ILI9341_DRIVER_TIMING_CONTROLB;
	ADDR_DATA=0x00;
	ADDR_DATA=0x00;
	ADDR_CMD=ILI9341_POWER_ON_SEQUENCE_CONTROL;
	ADDR_DATA=0x64;
	ADDR_DATA=0x03;
	ADDR_DATA=0x12;
	ADDR_DATA=0x81;
	ADDR_CMD=ILI9341_PUMP_RATIO_CONTROL;
	ADDR_DATA=0x20;
	ADDR_CMD=ILI9341_POWER_CONTROL1;
	ADDR_DATA=0x26;
	ADDR_CMD=ILI9341_POWER_CONTROL2;
	ADDR_DATA=0x11;
	ADDR_CMD=ILI9341_VCOM_CONTROL1;
	ADDR_DATA=0x35;
	ADDR_DATA=0x3E;
	ADDR_CMD=ILI9341_VCOM_CONTROL2;
	ADDR_DATA=0xBE;
	ili9341_orientation(1);
	ADDR_CMD=ILI9341_PIXEL_FORMAT_SET;
	ADDR_DATA=0x55;
	ADDR_CMD=ILI9341_FRAME_CONTROL_NORMAL;
	ADDR_DATA=0x00;
	ADDR_DATA=0x1B;
	ADDR_CMD=ILI9341_FUNCTION_CONTROL;
	ADDR_DATA=0x0A;
	ADDR_DATA=0x82;
	ADDR_DATA=0x27;
	ADDR_DATA=0x00;
	ADDR_CMD=ILI9341_ENABLE_3G;
	ADDR_DATA=0x08;
	ADDR_CMD=ILI9341_GAMMA_SET;
	ADDR_DATA=0x01;
	ADDR_CMD=ILI9341_POSITIVE_GAMMA_CORRECTION;
	ADDR_DATA=0x1F;
	ADDR_DATA=0x1A;
	ADDR_DATA=0x18;
	ADDR_DATA=0x0A;
	ADDR_DATA=0x0F;
	ADDR_DATA=0x06;
	ADDR_DATA=0x45;
	ADDR_DATA=0x87;
	ADDR_DATA=0x32;
	ADDR_DATA=0x0A;
	ADDR_DATA=0x07;
	ADDR_DATA=0x02;
	ADDR_DATA=0x07;
	ADDR_DATA=0x05;
	ADDR_DATA=0x00;
	ADDR_CMD=ILI9341_NEGATIVE_GAMMA_CORRECTION;
	ADDR_DATA=0x00;
	ADDR_DATA=0x25;
	ADDR_DATA=0x27;
	ADDR_DATA=0x05;
	ADDR_DATA=0x10;
	ADDR_DATA=0x09;
	ADDR_DATA=0x3A;
	ADDR_DATA=0x78;
	ADDR_DATA=0x4D;
	ADDR_DATA=0x05;
	ADDR_DATA=0x18;
	ADDR_DATA=0x0D;
	ADDR_DATA=0x38;
	ADDR_DATA=0x3A;
	ADDR_DATA=0x1F;
	ADDR_CMD=ILI9341_ENTRY_MODE_SET;
	ADDR_DATA=0x07;
	ADDR_CMD=ILI9341_SLEEP_OUT;
	delay_us(100*1e3);
	ADDR_CMD=ILI9341_DISPLAY_ON;
	delay_us(100*1e3);
}

void ili9341_orientation(char orien){
	ADDR_CMD = ILI9341_MEMORY_ACCESS_CONTROL;
	switch (orien){
		case 0: ADDR_DATA=0x48;	// Vertical normal
			break;
		case 1: ADDR_DATA=0x28;	// Horizontal normal
			break;
		case 2: ADDR_DATA=0x88;	// Vertical reverse
			break;
		case 3:ADDR_DATA=0xE8;	// Horizontal reverse
			break;
	}
	if (orien==0|orien==2){
		X_SIZE=240;
		Y_SIZE=320;
	}
	if (orien==1|orien==3){
		X_SIZE=320;
		Y_SIZE=240;
	}
}

void ili9341_set_area(short x0, short x1, short y0, short y1){
	ADDR_CMD = ILI9341_COLUMN_ADDRESS_SET;
	ADDR_DATA = x0>>8;
	ADDR_DATA = x0&0xFF;
	ADDR_DATA = x1>>8;
	ADDR_DATA = x1&0xFF;
	ADDR_CMD = ILI9341_PAGE_ADDRESS_SET;
	ADDR_DATA = y0>>8;
	ADDR_DATA = y0&0xFF;
	ADDR_DATA = y1>>8;
	ADDR_DATA = y1&0xFF;
}

void ili9341_set_value(short* src, int len){
	ADDR_CMD = ILI9341_MEMORY_WRITE;
	for (int i=0; i<len; i++){
		ADDR_DATA = *src++;
	}
}

void ili9341_set_pixel(short x0, short y0, short rgb565){
	ADDR_CMD = ILI9341_COLUMN_ADDRESS_SET;
	ADDR_DATA = x0>>8;
	ADDR_DATA = x0&0xFF;
	ADDR_DATA = x0>>8;
	ADDR_DATA = x0&0xFF;
	ADDR_CMD = ILI9341_PAGE_ADDRESS_SET;
	ADDR_DATA = y0>>8;
	ADDR_DATA = y0&0xFF;
	ADDR_DATA = y0>>8;
	ADDR_DATA = y0&0xFF;
	ADDR_CMD = ILI9341_MEMORY_WRITE;
	ADDR_DATA = rgb565;
}


